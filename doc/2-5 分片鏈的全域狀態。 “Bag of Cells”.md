# 2.5. 分片鏈的全域狀態。 “Bag of Cells”

現在我們準備描述TON區塊鏈的全域狀態，或者基礎工作鏈的分片鏈。我們從 “高級（
high-level）” 或 “邏輯（logical）” 描述開始，其中包括全域狀態是代數類型 ShardchainState
的值。

### 2.5.1	分片鏈狀態作為帳戶鏈狀態的集合。

根據“無限分片範式”（參見 2.1.2），任何分片鏈只是一個（臨時）虛擬 “帳戶鏈” 集合，每個只包含一個帳戶。這意味著，本質上，全域分片鏈狀態必須是一個hashmap。

$ShardchainState := (Account AccountState)$    (23)

如果我們正在討論分片的狀態$(w,s)$（參見 2.1.8），那麼所有出現在這個hashmap索引中的$account\_id$ 必須以首碼 s 開頭。

實際上，我們可能希望將 $AccountState$ 分成幾個部分（例如，將帳戶輸出訊息佇列分開以簡化相鄰分片鏈的驗證），並在 $ShardchainState$ 內部有幾個hashmap（$Account ➔ FountStatePart_i$）。我們還可以向 $ShardchainState$ 添加少量 “全域” 或 “整數” 參數（例如， 屬於該分片的所有帳戶的總餘額，或所有輸出佇列中的消息總數）。從 “邏輯”（“高級”）的角度來看，（23）是分片鏈全域狀態看起來的良好的第一步。$AccountState$ 和 $ShardchainState$ 形式描述的欄位可以借助 TL 方案（參見 2.2.5）完成。

### 2.5.2	拆分和合併分片鏈狀態。

請注意，分片鏈狀態（23）的無限分片範例描述顯示了在分割或合併分片時應如何處理此狀態。實際上，這些狀態轉換結果是使用hashmap的操作，非常簡單。

### 2.5.3	帳戶鏈狀態。

（虛擬）帳戶鏈狀態只是一個帳戶的狀態，由 $AccountState$ 欄位來描述。 通常它具有 2.3.20
中列出的全部或部分欄位，具體取決於所使用的具體構造函數。

### 2.5.4	全域工作鏈狀態。

與（23）類似，我們可以通過相同的公式定義全域工作鏈狀態，但允許使用 $account\_id$ 獲取任何值，而不僅僅是一個分片的值。 類似於 2.5.1 中的注釋也適用於這種情況：我們可能希望將該hashmap拆分為幾個hashmap，我們可能希望添加一些 “整數（integral）” 參數，例如總餘額。

本質上，全域工作鏈狀態必須由 和分片鏈狀態同類型的ShardchainState 給出，因為如果此工作鏈的所有現有的分片鏈合併為一個，我們將會獲得分片鏈的狀態。

### 2.5.5	Low-level （低級）來看：“Bag of Cells”。

帳戶鏈或分片鏈狀態的 “低級（low-level）” 描述也是對上面給出的 “高級（high-level）” 描述的補充。這個描述非常重要，因為它非常普遍，為通過網路去表示、存儲、序列化和傳輸TON 區塊鏈所使用的幾乎所有資料，提供了通用基礎（區塊、分片鏈狀態、智慧合約存儲、Merkle 證明等）。同時，這種普遍的 “低級” 描述一旦被理解和實施，就可以使我們只關注
“高級” 來考慮。

回想一下，TVM 通過 TVM cells樹或簡稱cells（參見 2.3.14 和 2.2.5）表示任意代數類型的值
（例如，包括（23）的 $ShardchainState$）。

任何這樣的cell由兩個描述符位元組組成，定義了某些標誌和值 $0≤b≤128$，原始位元組數，$0≤c≤4$，即對其他cell的引用數量。然後是 b 原始位元組和 c cell引用。$^{19}$

Cell引用的確切格式取決於實現以及cell是位於 RAM中，還是磁片、網路資料包、區塊中等等。一個有用的抽象模型在於想像所有cells都保存在內容可定址的記憶體中，cells的位址等於其
（sha256）雜湊。回想一下，一個cell的（Merkle）雜湊是通過用它（遞迴計算的）雜湊替換對其子cells的引用，並對生成的位元組串進行雜湊化來精確計算。

以這種方式，如果我們使用cells的雜湊來引用cells（例如，其他cells的內部描述），則系統稍微簡化，並且一個cell的雜湊開始與表示它的位元組串的雜湊重合。

現在我們看到 TVM 表示的任何物件，包括全域分片鏈狀態，可以表示為 “bag of cells”——例如，一組cells及對其中一個的 “根（root）” 引用（例如，通過雜湊） 。請注意，從此描述中刪除了重複的cells（“bag of cells” 是一組cells，而不是多重集合的細胞[a multiset of cells]）
，因此抽象樹表示可能實際上成為有向無環圖（DAG）表示。

有人甚至可能將這種狀態保存在 B-或 B + -tree 的磁片上，包含所有相關的cells（可能帶有一些額外的資料，如子樹高度或參考計數器），由cell雜湊索引。然而，這種想法的天真實現將導致一個智慧合約的狀態分散在磁片檔的遠端部分，我們寧願避免它。$^{20}$

現在我們將詳細解釋 TON 區塊鏈所使用的幾乎所有物件如何表示為一個“bag of cells”，從而
證明這種方法的普遍性。

### 2.5.6	分片鏈的區塊作為 “Bag of Cells”。

分片鏈的區塊本身也可以用代數類型描述，並存儲為一個 “bag of cells”。然後，可以簡單地通過以任意順序連接表示一個 “bag of cells”中每個cell的位元組串來獲得塊的樸素二進位表示。例如，通過在區塊頭提供所有cell的偏移列表，並且盡可能將該列表中具有 32 位元索引的其他

---

[19] 可以證明，如果同樣經常需要存儲在cells樹中的所有資料的Merkle樣張，則應該使用具有$b +ch≈2（h+r）$的cell來最小化平均Merkle校樣大小，其中$h = 32$是 散列大小（以位元組為單位），$r≈4$是cell引用的“位元組大小”。 換句話說，一個cell應該包含兩個引用和一些原始位元組，或者一個引用和大約36個原始位元組，或者根本不包含72個原始位元組的引用。

[20] 一種更好的實現是將智慧合約的狀態維持序列化字串（如果它很小），或者保存在單獨的B樹中（如果它很大）; 那麼代表區塊鏈狀態的頂級結構將是一個B樹，其葉子允許包含對其他B樹的引用。

cells的雜湊引用替換為該表示，可以改進和優化該表示。然而，人們應該想像一個塊本質上是一個 “bag of cells”，所有其他技術細節只是次要的優化和實現問題。

---

### 2.5.7	“Bag of Cells” 的對象。

想像一下，我們有一個舊版本的某個物件表示為 “bag of cells”，我們想要代表同一個物件的新版本，據說與前一個物件沒有太大差別。人們可能只是將新狀態表示為具有其自身根的另一個“bag of cells”，並從中移除舊版本中出現的所有cell。剩下的 “bag of cells” 本質上是物件的更新。擁有此物件的舊版本和更新的每個人都可以計算新版本，只需將兩組cells聯合起來，然後刪除舊的根（如果引用計數器變為零，則減少其引用計數器並取消分配cell） 。

### 2.5.8	更新帳戶狀態。

可以使用 2.5.7 中描述的思想來表示對帳戶狀態, 或分片鏈的全域狀態或任何hashmap的更新。 這意味著當我們收到一個新的分片鏈區塊（這是一個 “bag of cells”）時，我們不僅僅是單獨解釋這個 “bag of cells”，而是首先將它與代表分片鏈前一狀態的 “bag of cells” 結合起 來。 在這個意義上，每個塊可以 “包含（contain）” 區塊鏈的整個狀態。

### 2.5.9	區塊的更新

回想一下，一個區塊本身就是一個 “bag of cells”，因此，如果有必要編輯一個區塊，可以類似地將 “區塊更新（block update）” 定義為 “bag of cells”。在 “bag of cells”的情況下進行解釋， 則是該區塊的先前版本。這大致是 2.1.17 中討論的 “垂直塊（vertical blocks）” 背後的想法。

### 2.5.10	Merkle 證明作為 “Bag of Cells”。

請注意，（廣義）Merkle 證明——例如，一個斷言 $x [i] = y$ 從已知值 $Hash（x）= h$（參見
2.3.10 和 2.3.15）開始——也可以表示為 “bag of cells”。 也就是說，只需要提供一個cells的子集，該子集對應於從 $x：Hashmap（n,X）$的根到其所需分支的路徑，其索引為 $i:2^x$ $i:2x$和值y:X。對不處於該路徑上的這些cells的子集的引用，將在該證明中保持“未解析”，由cell雜湊表示。還可以提供同步的Merkle證明，如，$x [i] = y$和$x [i'] = y'$，通過包括在“bag of cells”中的cells，它們位於從x的根到對應於索引i和i'的葉子的兩條路徑的並集上。

### 2.5.11	Merkle 證明作為全節點的回應。

實質上，具有分片鏈（或帳戶鏈）狀態的完整副本的完整節點可以在輕節點（例如，運行TON 區塊鏈用戶端的輕節點）請求時提供 Merkle 證明，從而僅使用此 Merkle 證明中提供的cells，啟用接收器在沒有外部説明的情況下執行一些簡單的查詢。輕節點可以將序列化格式的查詢發送到整個節點，並通過 Merkle 證明或 Merkle 證明接收正確答案，因為請求者應該只能使用 Merkle 證明中包含的cells來計算答案。這個 Merkle 證明只包含一個 “bag of cells”， 只包含那些屬於分片鏈狀態的cells，這些cells在執行輕節點查詢時已被完整節點訪問。這種方法尤其可用于執行智慧合約的 “獲取查詢（get queries）”（參見 4.3.12）。

### 2.5.12	用 Merkle 有效證明增強更新和狀態更新。

回想一下（參見 2.5.7），我們可以從舊值（old value）x來描述物件狀態的變化：從X到一個新值$（new value）x'：X$通過一次“更新（update）”，它只是“bag of cells”，包含代表新值的子樹中的那些cell x'，但不在表示舊值 x 的子樹中，因為假定接收器具有舊值 x 及其所有cells 的副本。

但是，如果接收器沒有 x 的完整副本，但只知道它的（Merkle）雜湊 $h = Hash（x）$，它將無法檢查更新的有效性（即，所有 “dangling”cell更新中的引用確實引用 $x$）樹中的細胞。人們希望得到 “可驗證的（verifiable）” 更新，並通過 Merkle 證明舊狀態中所有被引用的細胞的存在。然後任何只知道 $h = Hash（x）$的人都能夠檢查更新的有效性並自己計算新的 $h'= Hash（ x'）$。

因為我們的 Merkle 證明本身就是 “bag of cells”（參見 2.5.10），所以可以將這樣的增強更新構建為 “bag of cells”，其中包含 x 的舊根，其中的一些後代以及來自 x 的根到它們，以及 x' 的新根和它不屬於 x 的所有後代。

### 2.5.13	分片鏈區塊中的帳戶狀態更新。

應如 2.5.12 中所討論的那樣，擴充分片鏈區塊中的帳戶狀態更新。 否則就有人可能會提交一個包含無效狀態更新的塊，例如舊狀態中缺少某個cell； 證明這種阻滯無效將是有問題的（質疑者將如何證明一個cell不屬於先前的狀態？）。

現在，如果塊中包含的所有狀態更新都得到了增強，則很容易檢查它們的有效性，並且它們的無效性也很容易顯示為違反（廣義）Merkle 雜湊的遞迴定義屬性。

### 2.5.14	“Bag of Cells”

先前的考慮表明，我們需要在 TON 區塊鏈或網路中存儲或傳輸的所有內容都可以表示為 “bag of cells”。這是 TON 區塊鏈設計理念的重要組成部分。一旦解釋了 “Bag of Cells” 方法並定義了 “bag of cells” 的一些 “low-level” 序列化，就可以在高層次簡單抽象定義出（依賴）代數資料類型的所有內容（區塊格式，分片鏈和帳戶狀態等）。“萬物皆a bag of cells” 統一的理念， 大大簡化了看似無關的服務的實施（比如 5.1.9 舉例涉及支付通道）。

### 2.5.15	TON 區塊鏈的區塊“頭（header）”。

通常，區塊鏈中的一個區塊以小頭開始，包含前一個區塊的雜湊，它自身的創建時間，區塊鏈中包含的所有交易的樹的 Merkle 雜湊，等等。然後將區塊雜湊定義為該小頭的雜湊。因為區塊頭最終取決於區塊中包含的所有資料，所以不能在不改變其雜湊的情況下改變區塊。

在 TON區塊鏈的區塊使用的 “bag of cells” 方法中，沒有指定的區塊頭。相反，區塊雜湊被定義為區塊的根cell的（Merkle）雜湊。因此，區塊鏈的頂部（根）cells可能被認為是該區塊的小 “頭（header）”。

但是，根cell可能不包含通常從這種區塊頭中預期的所有資料。實質上，需要區塊頭包含區塊資料類型(Block datatype)中定義的一些欄位。通常，這些欄位將包含在幾個cells中，包括根目錄。這些是共同構成所討論的欄位值的 “Merkle 證明” 的cells。有人可能會在任何其他cells 之前一開始就堅持要求一個區塊鏈包含這些 “header cells”。然後只需要下載區塊序列化的前幾個位元組，以獲得所有“header cells”，並知道所有預期的欄位。