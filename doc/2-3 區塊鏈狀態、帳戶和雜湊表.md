# 2.3. 區塊鏈狀態、帳戶和雜湊表

我們在上文中已經注意到，全域狀態由每一個區塊鏈來決定，每個區塊和每個交易都定義了全域狀態的變化。這裡我們描述TON區塊鏈使用的全域狀態。

### 2.3.1	帳戶 ID。

TON 區塊鏈使用的基礎帳戶ID——或者至少是其主鏈和初始工作鏈使用的基礎帳戶ID，是256 位元整數，對於一個特定的橢圓曲線，基礎帳戶ID假定為256位元橢圓曲線加密（ECC）的公開金鑰。用這種方式，

$account\_id : Account = uint256 = 2^{256}$	(9)

此處$Account$是帳戶類型，而 $account\_id$是帳戶類型的特定變數。
其他工作鏈可以使用其他帳戶ID格式，256位或其他。 例如，可以使用比特幣類型的帳戶ID， 等於ECC公開金鑰的SHA256。
但是，在創建工作鏈（在主鏈上）期間，帳戶ID的位長度l必須是固定的  ，並且它必須至少為
64位，因為$account\_id$的前64位是用於分片和按路由發送消息的。

### 2.3.2	主要組成部分：$Hashmaps$。

TON區塊鏈狀態的主要組成部分是$hashmap$。在某些情況下，我們考慮（部分定義）“map”$h：2^n ---> 2^m$。或者通俗地說，我們可能對雜湊圖 h 更感興趣：$h : 2^n --->X$ 表示複合型X。但是源（或索引）類型幾乎總是$2n$ 。
有時，我們的“預設值”為空值：$X$, 雜湊圖為 $h : → X$， “初始化”狀態是“預設值” i |→ 空值。

### 2.3.3	示例：TON帳戶餘額。

TON帳戶餘額給出了一個重要的例子：

$balance : Account → uint_{128}$	(10)

就是這個 hashmap將$Account = 2^{256}$ 映射至類型 $uint_{128}= 2^{128}$ 的Gram (TON coin)餘額。該
hashmap的預設值為零，這意味著最初（在處理第一個塊之前）所有帳戶的餘額為零。

### 2.3.4	示例：智慧合約的永久存儲。

另一個例子是智慧合約永久存儲，它可以（非常近似地）表示為一個hashmap：

$storage : 2^{256} ---> 2^{256}$	(11)

該hashmap的預設值也為零，意味著假設未初始化的永久存儲單元個數為零。

### 2.3.5	示例：永久存儲所有的智慧合約。

因為我們有多個智慧合約，由$account\_id$來區分，每個都要獨立的永久存儲，所以必須有一個
hashmap

$Storage : Account --->（2^{256} ---> 2^{256}）$	(12)

將智慧合約的 $account\_id$ 映射到其永久存儲裡。

### 2.3.6	hashmap的類型。

Hashmap不僅僅是一個抽象的（部分定義的）函數$2^n ---> X$； 它有一個特定的標記法。 因此
，我們假設我們有一個特殊的hashmap類型

$Hashmap(n, X) : Type$	   (13)

對應於編碼（部分）圖$2^n ---> X$的資料結構。我們也可以寫為

$Hashmap(n : nat)(X : Type) : Type$	(14)

或者

$Hashmap : nat → Type → Type$	(15)

我們也可以將$h : Hashmap(n, X)$轉換成一個$map：hget(h) : 2^n → X^?$。之後，我們通常寫$h[i]$來替代 $hget(h)(i)$：

$h[i] :≡ hget (h)(i) : X^?	對於任意 i : 2^n, h : Hashmap (n, X)$	(16)

### 2.3.7	把hashmap的類型當作Patricia樹。

從邏輯上講，可以將$Hashmap (n，X)$定義為深度為n的（不完整）的二叉樹（binary tree），
邊緣標籤為$0$和$1$，葉片中有類型X的值。描述相同結構的另一種方式是（按位元）首碼樹（trie
），用於長度等於 $n$ 的二進位字元串。

在實踐中，我們更喜歡使用此首碼樹的壓縮標記法，通過壓縮每個頂點的父節點只帶有一個子節點。結果表示為Patricia樹或者二進位基數樹。每個中間頂點現在有兩個子節點，由兩個非空二進位字元串標記，左邊子節點為0，右邊的子節點為1。

換句話說，Patricia樹中有兩種類型的（非根）節點：

- 葉子$LEAF(x)$, 包含類型$X$的值$x$；
- 節點$NODE (l,sl,r,s_r)$，其中l是對左邊子節點或子樹（的引用），$s_l$是用於標記連接此頂點到左邊子節點的邊緣的位元字串（總是從0開始），$r$是右邊的子樹，而$s_r$是位元字串用於右邊子節點的邊緣（總是以1開頭）。

第三種類型的節點，僅在Patricia樹的根部使用一次，也是必要的：

- 根$ROOT(n,s_0,t)$，其中$n$是$Hashmap (n,X)$的索引位元字串的公共長度，s0是所有索引位元字串的公共首碼，t是對Leaf或Node的引用。
如果我們想讓Patricia樹為空值，將使用第四種類型的（根）節點：
- 空根$EmptyRoot(n)$ ，其中n是所有索引位元串的公共長度。我們定義 Patricia 樹的高度

$HEIGHT (LEAF (x)) = 0$ 	(17)

$HEIGHT (NODE (l,s_l,r,s_r)) = HEIGHT (l) + LEN (s_l) = HEIGHT (r) + LEN (s_r)$	(18) 

$HEIGHT (ROOT (n,s_0,t)) = LEN (s_0) + HEIGHT (t) = n$	(19)

最後兩個公式中每個公式中的最後兩個運算式必須相等。我們使用高度為$n$的Patricia樹來表示
$Hashmap (n , X)$類型的值。
如果樹中有$N$葉子（即我們的hashmap包含$N$個值），則恰好有$N-1$個中間頂點。插入新值總是涉及通過在中間插入新頂點並添加新分支作為此新頂點的另一個分支來分割現有邊界。從雜湊表中刪除值則相反：刪除了一個葉子及其上級，則上級的上級與其他葉子直接連接。

### 2.3.8	Merkle-Patricia樹（MPT樹）。

使用區塊鏈時，我們希望能夠比較Patricia樹（即雜湊表）及其子樹，方法是將它們減少為單個雜湊值。Merkle樹給出了實現這一目標的經典方法。本質上，假使是我們知道如何計算物件x :  X的雜湊$HASH(x)$（例如，通過將雜湊函數 Hash應用於物件x的二進位序列化），借助為

二進位字元串定義的雜湊函數Hash，這是我們想要描述一種類型雜湊圖 Hashmap(n，X)的對
象h的一種方法。
可以遞迴地定義$HASH (h)$，如下所示：

$HASH (LEAF (x)) = HASH (x)$	(20) 

$HASH (NODE (l,s_l,r,s_r)) = HASH (HASH (l). HASH (r). CODE (s_l). CODE (s_r))$	(21)

$HASH (ROOT (n,s_0,t)) = HASH (CODE (n). CODE (s_0). HASH (t))$	(22)

這裡s.t表示（位元）字串s和t的關係，並且代碼CODE(s)是所有位元字串s的前置碼。例如， 可以用10編碼0，用11編碼1，在字串結尾用0編碼。6
稍後我們將看到（參見2.3.12和2.3.14）這是遞迴定義的雜湊函數的一個（稍微調整過的）版本，用於任意（從屬）代數類型的值。

### 2.3.9	重新計算Merkle樹的雜湊值。

這種遞迴定義$Hash (h)$的方式稱為Merkle樹雜湊，其優點是，如果一個人明確地將$Hash (h'）$ 與每個節點h'一起存儲（產生一個稱為Merkle樹的結構， 或者在我們的例子中，叫作
Merkle-Patricia樹），在hashmap中添加、刪除或更改一個元素時，只需要重新計算最多n個雜湊值。

用這種方法，如果通過合適的Merkle樹雜湊表示全域區塊鏈狀態，則在每次交易後很容易重新
計算此狀態雜湊值。

### 2.3.10	Merkle證明。

所選雜湊函數Hash在 “內射” （injectivity）的假設（7）下，我們可以構造一個證明，對於Hash (h)的給定值$z$，$h：Hashmap (n,X)$，有一個$hget (h)(i) = x$， 對於某些 $i: 2^n$ 和 $x:X$。這樣的證明將包括 $Merkle-Patricia$樹中的路徑，這種路徑從對應于i到葉子到根，由出現在路徑上的所有兄弟節點的雜湊值來增強。

以這種方式，一些僅知道雜湊圖h的Hash (h)值的輕節點7（例如，智慧合約永久存儲或全域區塊鏈狀態）可以從完整節點8請求，請求的內容不僅是值 $x = h [i] = hget (h) (i)$，而且是伴隨著從已知值 $Hash (h)$開始的Merkle證明。然後，在假設（7）下，輕節點可以檢查自身，x確實是h [i]的正確值。

而在一些情況下，用戶端可能想要獲得值 $y = Hash（x）= Hash (h [i])$——例如，如果 $x$ 本身非常大（例如，hashmap本身）。然後可以提供$(i , y)$的Merkle證明。如果$x$也是雜湊函數，則從 $y=Hash (x)$開始的第二個Merkle證明可以從完整節點獲取，以提供值 $x[j] = h [i] [j]$ 或僅其雜湊值。

---

6 可以表明這種編碼對於帶有隨機或連續索引的$Patricia$樹的幾乎一半邊緣標籤是最佳的。剩餘的邊緣標籤可能很長（即幾乎256位長度）。因此，邊緣標籤的近似最佳編碼是使用上面的代碼，該代碼用首碼為0表示“短”位元串字串，並編碼1，剩下9位元包含位元字串$s$的長度$l = |s|$，然後用s的l表示“長”位元字串
$（l ≥ 10）$
7 輕節點不追蹤分片鏈的完整狀態;相反，它保留最少的資訊，例如最近幾個塊的雜湊值，並且當需要檢查完整狀態的某些部分時，依賴於從完整節點獲得的資訊。
8 完整節點用於追蹤被提及的分片鏈的完整最新狀態。

---

### 2.3.11	對於諸如TON的多鏈系統，Merkle證明的重要性。

請注意，節點通常不能是存在於TON環境中所有分片鏈的完整節點。它通常是一種針對一些分片鏈的全節點——例如，那些包含自己帳戶的分片鏈，對智慧合約感興趣的分片鏈，或者這個節點被指定為驗證人的那些分片鏈。對於其他的分片鏈，它必須是一個輕節點——否則存 儲、計算和網路頻寬要求會非常高。這意味著這樣的節點不能直接檢查關於其他分片鏈狀態的斷言（assertion）； 對於這些分片鏈，它必須依賴于從全節點獲得的Merkle 證明，這與自身檢查一樣安全，除非(7)失敗（即發現雜湊衝突）。

### 2.3.12	TON VM的特點。

用於在主鏈和初始工作鏈中運行智慧合約的TON VM或TVM（Telegram虛擬機器）與受EVM
（乙太坊虛擬機器）啟發的傳統設計有很大不同：它不僅用256位元整數操作 ，而且實際上（幾乎是）帶有任意 “記錄”、“結構” 或 “和產品類型”，使其更適合執行用高級（特別是函數程式設計）語言編寫的代碼。 從本質上講，TVM使用標記資料類型，與實現Prolog或Erlang時使用的資料類型還不同。

人們首先可能想到的是，TVM智慧合約的狀態不僅僅是一個$hashmap 2^{256} → 2^{256}$，或者$Hashmap (256 , 2^{256} )$，但是（作為第一步）$Hashmap (256 , X)$，其中X是具有多個構造函數的類型，使其能夠存儲除256位元整數之外的其他結構的資料，包括其他hashmap，特別是$Hashmap (256 , X)$。這意味著TVM（永久或臨時）存儲的單元——或 TVM 智慧合約代碼中的變數或陣列元素——不僅可以包含整數，而且可以包含全新的雜湊表。當然，這意味著一個單元不僅包含256位元，而且還包含一個8位標籤，描述了如何解析這個256位。

實際上，值不需要精確為 256 位。TVM 使用的值的格式包括一系列原始位元組和對其他結構的引用，以任意順序混合，其中一些描述符位元組插入適當的位置，以便能夠區分指標與原始資料
（例如，字串或整數）；參照 2.3.14。

該原始值格式可用於實現任意和積（SPN）代數類型。在這種情況下，該值首先包含一個原始位元組描述正在使用的 “構造函數”（從高階語言的角度來看），然後是其他 “欄位” 或 “構造函數參數”，其中包括原始位元組和對其他結構的引用，這些結構取決於所選擇的構造函數（參見2.2.5）。然而，TVM對構造函數與其參數之間的對應關係一無所知；位元組和引用的混合由某些描述符位元組明確描述。9

Merkle樹雜湊擴展到任意這樣的結構：為了計算這種結構的雜湊，所有引用都提及物件的雜湊
值遞迴替換，然後計算得到的結果位元組字串（包括描述符位元組）的雜湊。

通過這種方式，2.3.8中描述的針對Hashmap的Merkle樹雜湊，只是對任意（依賴型）代數資料類型進行雜湊的特殊情況，應用於具有兩個構造函數的$Hashmap (n,X)$類型。10

### 2.3.13	永久存儲TON智慧合約。

---

9 存在於任何TVM細胞中的這兩個描述符位元組僅描述引用和原始位元組的總數；參考文獻在所有原始位元組之前或者之後一起保存。
10 實際上，Leaf和Node是輔助類型$HashmapAux (n,X)$的構造函數。類型$Hashmap (n,X)$帶有構造函數Root和EmptyRoot，其中Root包含類型$HashmapAux (n,X)$的一個值。

---

對於一個TON智慧合約的永久存儲本質上由它的 “全域變數”組成，這些“ 全域變數”保存在智慧合約的調用之間。因此，它只是一個 “產品”、“元組” 或 “記錄” 類型，由正確類型的欄位組成
，每個欄位對應一個全域變數。如果全域變數太多，由於對TON單元體積的全域限制，它們則不能歸屬於一個TON單元。在這種情況下，它們被分成若干記錄並組織成樹，本質上成為了 “產品的產品” 或 “產品的產品的產品” 類型，而不僅僅是產品類型。

### 2.3.14	TVM單元。

最終，TON VM將所有資料保存在（TVM）單元的集合（Collection）中。每個單元首先包含兩個描述符位元組，指示該單元中存在多少位元組的原始資料（最多 128 個），以及存在多少個對其他單元的引用（最多四個）。然後是這些原始資料位元組和引用。每個單元只被引用一次， 因此我們可能已經在每個單元中包含對其 “父” （引用該單元的唯一單元）的引用。但是，該引用不必明確說明。

以這種方式，TON智慧合約的永久資料存儲單元被組織成樹11，其中智慧合約描述中保存了對該樹的根的引用。如有必要，整個永久記憶體的Merkle樹雜湊值被遞迴計算了，從樹葉開始， 然後簡單地用被引用單元的遞迴計算的雜湊值代替一個單元中的所有引用，並隨後計算由此獲得的位元組字串的雜湊值。

### 2.3.15	任意代數類型值的廣義Merkle證明。

因為TON VM通過由（TVM）單元組成的樹來表示任意代數類型的值，並且每個單元具有明確定義的（遞迴計算的）Merkle雜湊，實際上取決於根據該儲存格生成的整個子樹，所以我們可以為任意代數類型的（部分）值提供 “廣義Merkle 證明”，旨在證明具有已知Merkle雜湊的樹的某個子樹採用特定值或具有特定雜湊的值。這概括了 2.3.10的方法，其中只考慮了$x[i] = y$的Merkle證明。

### 2.3.16	支援TON VM資料結構中的分片。

我們剛剛概述了TON VM如何在不過度複雜的情況下支援高級智慧合約語言中的任意（依賴型）代數資料類型。但是，大型（或全域）智慧合約的分片需要在TON VM層面提供特殊支援。為此，系統中添加了特殊版本的hashmap類型，相當於一個 “map” $Account ---> X$。這個“map” 似乎等同於$Hashmap (m,X)$，其中$Account = 2^m$。但是，當分片一分為二或兩個分片合併時，這些雜湊圖會自動拆分成兩個或合併回來，目的是為了保持只有那些屬於相應分片的鑰。

### 2.3.17	為永久存儲支付。

TON區塊鏈的一個值得注意的特徵是從智慧合約中提取的支付的用於存儲其永久資料的支付
（即，用於擴大區塊鏈的總狀態）。它的工作原理如下：

每個區塊有兩種費率，以區塊鏈的主要貨幣（通常是 Gram）指定：一種是將一個單元保留在永久存儲中的價格，另一種是在永久存儲的某個單元中保留一個原始位元組的價格。每個帳戶使用的細胞和位元組總數的統計資訊存儲為其狀態的一部分，因此通過將這些數位乘以區塊頭中的

---

11 從邏輯上講， 2.5.5中描述的“bag of cells””表述確認所有重複單元，在序列化時將此樹轉換為有向無
環圖（dag）。

---

兩種費率，我們可以計算要從帳戶餘額中扣除的付款以便在前一個區塊和當前區塊之間保留資料。

但是，為使用永久存儲而付款，並不強求每個區塊中的每個帳戶和智能合約；相反，最後要求該支付的區塊序號存儲在帳戶資料中，當該帳戶進行任何動作時（例如，通過智慧合約接收和處理價值轉移或消息）， 在執行任何進一步動作之前，會從帳戶餘額中扣除從上一次此類付款以來的所有區塊的存儲使用費用。如果此後帳戶的餘額將變為負數，則該帳戶將被銷毀。工作鏈可以聲明每個帳戶的一些原始資料位元組是 “免費” 的（即，不參與永久性存儲支付）， 以便製作 “簡單” 帳戶，這些帳戶僅用一種或兩種加密貨幣保留餘額，而不用不斷付款。

請注意，如果沒有人向帳戶發送任何消息，則不會收集其永久存儲費用，並且帳戶可以一直存在。但是，任何人都可以發送一條空消息來銷毀這樣的帳戶。想要銷毀帳戶餘額的部分作為小激勵，會提供給這樣的消息的發送者。 我們預計驗證人將樂意銷毀此類資不抵債的帳戶，只是為了減少全域區塊鏈的規模，避免無償地保留大量資料。

為保持永久性資料而收集的付款分佈在分片鏈或主鏈的驗證人之間（後一種情況下與他們的質
押成比例）。

### 2.3.18	本地和全域智能合約；智慧合約實例。

智慧合約通常只存在於一個分片中，根據智慧合約的 $account\_id$ 選擇，類似于 “普通” 帳戶。對於大多數應用來說，這通常就足夠了。然而，一些 “高負荷” 的智慧合約可能希望在某些工作鏈的每個分片鏈中都有一個 “實例”。為了實現這一點，他們必須將他們的創建的交易傳播到所有分片鏈中，例如，通過將此交易提交到工作鏈的 “root”分片鏈$(w，∅)$12並支付大額傭金。13 此操作在每個分片中有效地創建了智慧合約的實例，並具有單獨的餘額。最初，在創建交易中傳輸的餘額簡單地通過在$shard (w,s)$中給出的實例$2−|s|$作為總餘額的一部分來分佈。當分片分成兩個子分片時，所有全域智慧合約實例的餘額分成兩半；當兩個分片合併時，餘額會加在一起。

在某些情況下，拆分/合併全域智慧合約的實例可能涉及（延遲）執行這些智慧合約的特殊方法。預設情況下，拆分和合併餘額如上所述，並且一些特殊的 “帳戶索引” hashmap也會自動拆分和合併（參見 2.3.16）。

### 2.3.19	限制智慧合約的分割。

全域智慧合約可能會在創建時限制其拆分深度d，以便使永久存儲費用更具可預測性。這意味著，如果$shardchain (w，s)$（其中$| s | ≥ d$）分為兩部分，兩個新的分片鏈中只有一個接替了智慧合約的一個實例。這種分片鏈的選擇是確定性的：每個全域智慧合約都有一些“$account\_id$”，它本質上是創建的交易的雜湊值，並且其實例具有相同的$account\_id$，其中第一個≤d的位替換為落入正確分片所需的適當值。此$account\_id$選擇在拆分後由哪個分片接替智慧合約實例。

### 2.3.20	帳戶 / 智慧合約狀態。

我們可以總結以上所有內容，得出結論：帳戶或智慧合約狀態包含以下內容：

- 區塊鏈主要貨幣的餘額

---

12 一種更昂貴的替代方案，目的是在主鏈中發佈這種“全域”智慧合約。
13 這是所有分片的一種“廣播”功能，因此它必然是非常昂貴的。

---

- 區塊鏈的其他貨幣餘額
- 智能合約代碼（或其雜湊）
- 智慧合約永久性資料（或其Merkle雜湊）
- 永久存儲單元數和使用的原始位元組數的資料統計
- 最後一次收集智慧合約永久存儲付款（實際上是主鏈區塊編號）
- 從此帳戶傳輸貨幣和發送消息所需的公開金鑰（可選；預設情況下等於$account_id$本 身）。在某些情況下，可以在此處找到更複雜的用於檢查代碼的簽名，類似於比特幣交易輸出所做的操作； 然後account_id 將等同於此代碼的雜湊值。
我們還需要在帳戶狀態或其他一些帳戶索引的雜湊圖中保留以下資料：
- 帳戶的輸出訊息佇列（參見 2.4.17）
- 最近發送的消息（雜湊）的集合（參見 2.4.23）
並非所有這些都是每個帳戶真正需要的；例如，智慧合約代碼僅適用于智慧合約，但不適用於“簡單” 帳戶。 此外，雖然任何帳戶的主要貨幣的餘額必須非零（例如，基礎工作鏈的主鏈和分片鏈的Grams），但其他貨幣的餘額可能為零。為了避免保留未使用的資料，（在工作鏈的創建期間）我們定義了一個sum-product類型（取決於工作鏈），它使用不同的標記位元組（例如，TL 構造函數；參見 2.2.5）來區分不同的 “ 構造函數 “使用。最終，帳戶狀態本身被保存為TVM 永久存儲的單元集合。