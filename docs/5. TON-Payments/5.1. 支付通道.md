# 5.1. 支付通道

我們首先討論點對點支付通道，以及如何在 TON 區塊鏈中實施這些通道。

### 5.1.1 支付通道的思路

假設 A 和 B 兩方都知道他們將來需要相互支付很多款項。他們不用將每筆付款提交到區塊鏈中交易，而是創建一個共用的"資金池"(或者也可能是一個只有兩個帳戶的小型私人銀行)， 並為其提供一些資金：$A$ 貢獻 $a$ 幣，$B$ 貢獻 $b$ 幣。這是通過在區塊鏈中創建一個特殊的智慧合約並將資金發送給智慧合約來實現的。
在創建"資金池"之前，雙方同意某個協議。他們將追蹤池的狀態——即共用池中的餘額。最初
，狀態是$(a,b)$，意思是a幣實際上屬於 $A$，$b$ 幣屬於 $B$。然後，如果 $A$ 想要向 $B$ 支付d幣
，他們可以簡單地同意新狀態是$(a ',b')=(a - d,b + d)$。之後，如果 $B$ 想要向 $A$ 支付 $d'$ 幣，那麼狀態將成為$(a'',b'')=(a'+ d',b' - d')$，依此類推。

所有這些池內餘額的更新都完全在鏈下完成。當雙方決定從池中取出應付資金時，他們會根據池的最終狀態進行操作。這是通過向智慧合約發送特殊消息來實現的，其中包含商定的最終狀態$(a *,b *)$以及 $A$ 和 $B$ 的簽名。然後智慧合約向 $A$發送$a *$幣，向B發送$b *$幣，並扣除自己的部分。

此智慧合約、以及 $A$ 和 $B$ 用於更新池子狀態的網路通訊協定是 $A$ 和 $B$ 之間的簡單支付通道。根據
4.1.2 中描述的分類，它是一種混合服務：其部分狀態存在于區塊鏈(智慧合約)中，但其大多數狀態更新都是鏈下(通過網路通訊協定)執行的。如果一切順利，雙方將能夠按照自己的意願執行盡可能多的付款(唯一的限制是通道的容量不會超支——即，他們在付款通道中的餘額都大於0)，只要將兩個交易提交到區塊鏈中：一個用於打開(創建)支付通道(智慧合約)， 另一個用於關閉(銷毀)通道。

### 5.1.2 無需信任的支付通道

前面的例子有點不切實際，因為它假設雙方都願意合作，絕不會用欺騙的手段獲得一些好處。想像一下，假如$A$  在$a'$<a的情況下，會選擇不簽署最終出餘額$(a'，b')$。這將使 $B$  陷入困境。

為防止這種情況，人們通常會嘗試開發無需信任的支付通道協定，這些協定不要求各方相互信任，並規定懲罰任何試圖作弊的人。
這通常借助簽名來實現。支付通道智慧合約知道 $A$ 和 $B$ 的公開金鑰，並且如有必要，可以檢查他 們的簽名。支付通道協定要求各方簽署中間狀態並將簽名發送給彼此。然後，如果其中一方欺騙——例如假裝支付通道的某些狀態從未存在——可以通過在該狀態上顯示其簽名來證明其不當行為。支付通道智慧合約充當"鏈上仲裁者"，能夠處理雙方關於彼此的投訴，並通過沒收所有資金並將其授予另一方來懲罰作惡方。

### 5.1.3 簡單、雙向同步的無需信任支付通道

考慮以下更實際的例子：支付通道的狀態由三元組$(δi, i, oi )$描述，其中 i 是狀態的序號
(原始數值是零，隨後出現一個狀態，數值增加1)，$δi$ 是通道不平衡(意味著 $A$ 和 $B$ 分別擁有 $a+δi$ 和 $b − δi$ 幣)，並且 $oi$ 是允許產生下一狀態($A$ 或 $B$)的一方。 在取得進一步進展之前，每個狀態必須由 $A$ 和 $B$ 簽署。

現在，如果 $A$ 想要將 $d$ 幣轉移到支付通道內的 $B$，並且當前狀態是 $Si = (δi, i, oi)$ ，其中 $oi = A$
，則它只是創建一個新狀態 $S_i+1 = (δi − d, i + 1, oi+1)$ ，簽名，並將其連同其簽名一起發送給$B$。然後 $B$ 通過簽名並將其簽名副本發送給 $A$ 來確認。之後，雙方都擁有含新簽名的新狀態的副本，並且可能會有新的轉帳。

如果 $A$ 想要在具有 $oi = B$的$Si$狀態中將幣轉到 $B$，則它首先要求 $B$ 提交$Si+1$的後續狀態，具有相同不平衡$δi+1 = δi$，但是$oi+1 = A$ 。之後，$A$ 將能夠進行轉帳。
當雙方同意關閉支付通道時，他們都將他們的特殊最終簽名放在他們認為是最終的狀態 $Sk$ 上，並通過發送最終狀態和最終簽名來調用支付通道智慧合約的最終或雙方最終確定的方法。

如果另一方不同意提供其最終簽名，或者僅僅是停止回應，則可以單方面關閉該通道。為此， 想這麼做的一方將調用單方面的最終確定方法，向智慧合約發送其最終狀態的版本、最終簽名以及具有另一方簽名的最新狀態。在此之後，智慧合約不會立即對收到的最終狀態採取行動。相反，它會等待一段時間(例如，一天)以使另一方呈現其最終狀態的版本。當另一方提交其版本並且結果與已提交的版本相容時，"真實"的最終狀態由智慧合約計算並相應地分配資金。如果另一方未能將其最終狀態的版本呈現給智慧合約，則根據所呈現的最終狀態的唯一副本重新分配資金。
如果雙方中有一方作弊——例如，簽署兩個不同的作為最終狀態，或者簽署兩個不同的下一狀態 $Si+1$ 和 $S' i+1$，或者簽署無效的新狀態 $Si+1$ (例如，不平衡狀態$δi+1 <-a $或$> b$)——則另一方可以提交這種不當行為的證明到智慧合約的第三種方法。作惡的一方將立即受到懲罰，完全失去其在支付通道中的份額。

這種簡單的支付通道協議是公平的，即無論是否有另一方的合作，任何一方都可以隨時獲得應付款，並且如果它試圖作弊，可能會失去提交到支付通道的所有資金。

### 5.1.4	同步支付通道，一個帶有兩個驗證人的簡單的虛擬區塊鏈

以上簡單、同步支付通道的示例可以按以下操作重新製作。想像一下，狀態序列 $S0, S1, ..., Sn$
實際上是非常簡單的區塊鏈的區塊序列。該區塊鏈的每個區塊基本上僅包含區塊鏈的當前狀態
，並且可能是對前一個區塊的引用(即，其雜湊值)。$A$ 和 $B$ 雙方都充當此區塊鏈的驗證人
，因此每個區塊必須收集其兩個簽名。區塊鏈的狀態 $Si$ 定義為下一個區塊的指定生產者 $oi$， 因此 $A$ 和 $B$ 之間沒有生成下一個區塊的競爭。出塊節點 $A$ 可創建區塊，將資金從 $A$ 轉移到 $B$
(即，減少不平衡：$δi+1 ≤ δi$) ，並且 $B$ 只能將資金從 $B$ 轉移到 $A$(即，增加$δ$)。
如果兩個驗證人就區塊鏈的最終區塊(和最終狀態)達成一致，則通過收集雙方的特殊"最終" 簽名來最終確定，並將其與最終區塊一起提交給通道智慧合約進行處理和相應地重新分配資金。

如果驗證人簽署了無效區塊，或者創建了一個分叉，或者簽署了兩個不同的最終區塊，則可以通過向智慧合約提供其不當行為的證據來懲罰它，該合同充當兩個驗證人的"鏈上仲裁者"；然後，違方將失去保留在支付通道中的所有資金，這類似於失去其 stake 的驗證人。

### 5.1.5	非同步支付通道，具有兩個工作鏈的虛擬區塊鏈

5.1.3 中討論的同步支付通道具有一定缺陷：在另一方沒有確認之前的交易之前，不能開始下一筆交易(支付通道內的匯款)。這可以通過用兩個交互虛擬工作鏈(或者說是分片鏈)的系統替換 5.1.4 中討論的單鏈虛擬區塊鏈來解決。
這些工作鏈中的第一條僅包含 $A$ 的事務，區塊只能由 $A$ 生成；它的狀態是 $Si = (i, φi, j, ψj )$, 其中 $i$ 是區塊序號(即到目前為止由 $A$ 執行的交易或匯款的數量)，$φi$ 是目前為止從 $A$ 轉移到$B$ 的總量，$j$ 是 $A$ 知道的 $B$ 區塊鏈中最近有效區塊的序號，$ψj$ 是其 $j$ 交易中從 $B$ 轉移到 $A$ 的金額。放在第 $j$ 個塊上的 $B$ 的簽名也應該是這個狀態的一部分。也可以包括該工作鏈的前一個塊和另一個工作鏈的第 $j$ 個塊的雜湊。如果 $i > 0, ψj ≥ 0$ 且$-a≤ψj−φi≤b$，$Si$的有效性條件包括$φi ≥ 0, φi ≥ φi−1$。
類似地，第二個工作鏈僅包含 $B$ 的交易，區塊僅由 $B$ 生成；其狀態為 $Tj = (j, ψj , i, φi)$ ，具有相似的有效性條件。

現在，如果 $A$ 想要將一些錢轉移到 $B$，它只需在其工作鏈中創建一個新塊，簽名併發送給 $B$，無需等待確認。

支付通道由 $A$ 簽署(其版本)區塊鏈的最終狀態(具有特殊的"最終簽名")，$B$ 簽署其區塊鏈的最終狀態，並將這兩個最終狀態呈現給支付通道智慧合約的最終確定方法。單方最終確定也是可能的，但在這種情況下，智慧合約必須等待另一方提交其最終狀態的版本，至少需要一定寬限期。

### 5.1.6 單向支付通道

如果只有 $A$ 需要向 $B$ 付款(例如，$B$ 是服務提供者，$A$ 是其客戶)，則可以創建單邊支付通道。從本質上講，它只是 5.1.5 中描述的沒有第二條工作鏈的第一條工作鏈。相反，可以說
5.1.5 中描述的非同步支付通道由兩個單向支付通道組成，或由同一智慧合約管理的"半通道"組成。

### 5.1.7 更複雜的支付通道，授權

我們將在後面的 5.2.4 中看到，"閃電網路"(參見 5.2)，通過幾個支付通道的鏈實現即時匯
款，需要所涉及的支付通道更加複雜。

特別是，我們希望能夠提交"授權"或"有條件轉帳"：$A$ 同意向 $B$ 發送 $c$ 幣，但 $B$ 只有在滿足某個條件時才會獲得資金(例如，$B$ 可以用一個已知的 $v$ 值表示$Hash(u) = v$)。否則，$A$ 可以在一段時間後收回資金。
這樣的授權可以通過簡單的智慧合約在鏈上輕鬆實現。我們希望授權和其他類型的有條件轉帳可以在鏈下支付通道中進行，因為它們可以大大簡化"閃電網路"中存在的支付通道鏈上的資金轉移(參見 5.2.4)。

5.1.4 和 5.1.5 中概述的"支付通道，簡單的區塊鏈"方案在這裡變得很方便。現在我們考慮一個更複雜的虛擬區塊鏈，其狀態包含一系列未實現的"授權"，以及鎖定在此類授權中的資金數 量。這個區塊鏈——或非同步情況下的兩個工作鏈——必須通過它們的雜湊明確引用之前的區塊。不過，整個機制仍然相同。

### 5.1.8	複雜的支付通道智慧合約面臨的挑戰

請注意，雖然複雜的支付通道的最終狀態仍然很小，而且最終確定很簡單(如果雙方已就其應付金額達成一致，並且雙方已簽署協議，就無需做其他事)，但單邊確定方法和懲罰欺詐行為的方法需要更加複雜。實際上，他們必須能夠接受默克爾校驗不正當行為，並檢查支付通道鏈上更複雜的交易是否在正確處理。
換句話說，支付通道智慧合約必須能夠使用默克爾校驗，檢查其"雜湊有效性"，並且必須包含支付通道(虛擬)鏈的 $evtrans$ 和 $evblock$ 功能的實現(參見 2.2.6)。

### 5.1.9	TON VM	"智能"

用於運行 TON區塊鏈智慧合約代碼的 TON VM 可以應對執行"智慧"或複雜支付通道所需的智慧合約(參見 5.1.8)。
在這一點上，"everything is a bag of cells" 範例(參見 2.5.14)變得非常方便。由於所有塊
(包括臨時支付通道區塊鏈的塊)都表示為a bag of cells(並由一些代數資料分片描述)，並且同樣適用於消息和默克爾校驗，因此可以輕鬆地將默克爾校驗嵌入到發送到支付通道智慧合約的入站消息。默克爾校驗的"雜湊條件"將會自動進行檢查，並且當智慧合約訪問所呈現的"默克爾校驗"時，它的使用方式就好像它是相應的代數資料分片的值——儘管不完整，樹的一些子樹被包含省略子樹的默克爾雜湊的特殊節點替換。然後，智慧合約將使用該值，該值可能代表支付通道(虛擬)區塊鏈的塊及其狀態，並將評估該區塊的區塊鏈的 ev_block 功能(參見2.2.6)和以前的狀態。然後，計算結束，並且可以將最終狀態與區塊中斷言的狀態進行比較
，或者在嘗試訪問缺席子樹時拋出"缺席節點"異常，表明默克爾校驗無效。

通過這種方式，使用 TON 區塊鏈智慧合約實現智慧支付通道區塊鏈的驗證碼變得非常簡單。有人可能會說，TON 虛擬機具有內置支援，可以檢查其他簡單區塊鏈的有效性。唯一的限制因素是要合併到智慧合約(即進入交易)的入站消息中默克爾校驗的大小。

### 5.1.10	智慧支付通道內的簡單支付通道

我們想討論在現有支付通道內創建簡單(同步或非同步)支付通道的可能性。

雖然這看起來有點令人費解，但理解和實施並不比 5.1.7 中討論的"授權"困難得多。基本上， 如果出現一些雜湊問題的解決方案，並不是承諾向另一方支付 $c$ 幣，$A$ 承諾根據某些其他(虛擬)支付通道區塊鏈的最終結算向 $B$ 支付最多 $c$ 幣。一般來說，這個其他支付通道區塊鏈甚至不需要在 $A$ 和 $B$ 之間；它可能涉及其他方，比如 $C$ 和 $D$ 將分別提交 $c$ 和 $d$ 幣至其簡單的支付通道。(這種可能性在後面的 5.2.5 中使用。)
如果包含的支付通道是不對稱的，則需要將兩個授權提交到兩個工作鏈中：如果"內部"簡單支付通道的最終結算產生負的最終不平衡$δ$且 $0≤-δ≤c$，$A$ 將承諾向 $B$ 支付$-δ$個幣；如果$δ$為正， 則 $B$ 必須承諾向 $A$ 支付$δ$。另一方面，如果包含支付通道是對稱的，這可以通過由A將單個含參數$(c,d)$的"簡單支付通道創建"交易一起提交到單個支付通道區塊鏈中來完成(這將凍結屬於$A$的 $c$ 幣)，然後由 $B$ 進行特殊的"確認交易"(這將凍結 $B$ 的$d$幣)。
我們希望內部支付通道非常簡單(例如，5.1.3 中討論的簡單同步支付通道)，以使要提交的默克爾校驗的大小最小化。在上，外部支付通道必須是5.1.7 意義上的"智慧"。